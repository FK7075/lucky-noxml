Index: src/main/java/com/lucky/jacklamb/quartz/proxy/QuartzMethodInterceptor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.lucky.jacklamb.quartz.proxy;\n\nimport com.lucky.jacklamb.ioc.ApplicationBeans;\nimport com.lucky.jacklamb.quartz.TargetJobRun;\nimport com.lucky.jacklamb.quartz.ann.Job;\nimport com.lucky.jacklamb.quartz.exception.CronExpressionException;\nimport com.lucky.jacklamb.quartz.job.LuckyJob;\nimport com.lucky.jacklamb.quartz.job.SerialJob;\nimport com.lucky.jacklamb.utils.reflect.MethodUtils;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport org.quartz.*;\nimport org.quartz.impl.DirectSchedulerFactory;\nimport org.quartz.impl.StdSchedulerFactory;\nimport org.quartz.spi.JobStore;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport static com.lucky.jacklamb.quartz.constant.Constant.LUCKY_JOB;\nimport static com.lucky.jacklamb.quartz.constant.Constant.LUCKY_JOB_GROUP;\nimport static org.quartz.DateBuilder.futureDate;\nimport static org.quartz.SimpleScheduleBuilder.simpleSchedule;\n\npublic class QuartzMethodInterceptor implements MethodInterceptor {\n\n    private static Map<Method,JobKey> specialJobMap=new HashMap<>();\n\n\n    @Override\n    public Object intercept(Object targetObj, Method method, Object[] params, MethodProxy methodProxy) throws Throwable {\n        if(method.isAnnotationPresent(Job.class)){\n            Job quartzJob = method.getAnnotation(Job.class);\n            String jobName= UUID.randomUUID().toString();\n            if(quartzJob.onlyFirst()){\n                if(specialJobMap.containsKey(method)){\n                    return methodProxy.invokeSuper(targetObj,params);\n                }\n            }\n//            JobStore jobStore=\n//            DirectSchedulerFactory.getInstance().createScheduler();\n            Scheduler  scheduler = StdSchedulerFactory.getDefaultScheduler();\n            Class<? extends org.quartz.Job> jobClass=quartzJob.parallel()?LuckyJob.class: SerialJob.class;\n\n            //封装任务逻辑\n            TargetJobRun targetJobRun=new TargetJobRun(targetObj,methodProxy,params);\n            String jobRunBeanId=UUID.randomUUID().toString();\n            ApplicationBeans.createApplicationBeans().addComponentBean(jobRunBeanId,targetJobRun);\n            JobDetail jobDetail = JobBuilder.newJob(jobClass)\n                    .withIdentity(jobName, LUCKY_JOB_GROUP)\n                    .build();\n            //将任务逻辑的IocId put到上下文中\n            jobDetail.getJobDataMap().put(LUCKY_JOB,jobRunBeanId);\n            Map<String, Object> paramKV = MethodUtils.getClassMethodParamsNV(method, params);\n            Trigger trigger =getTrigger(paramKV,method,quartzJob,jobName);\n            scheduler.scheduleJob(jobDetail,trigger);\n            if(quartzJob.onlyLast()&&specialJobMap.containsKey(method)){\n                scheduler.pauseJob(specialJobMap.get(method));\n                scheduler.deleteJob(specialJobMap.get(method));\n            }\n            if(quartzJob.onlyFirst()||quartzJob.onlyLast())\n                specialJobMap.put(method,jobDetail.getKey());\n            scheduler.start();\n            return null;\n        }\n        return methodProxy.invokeSuper(targetObj,params);\n    }\n\n    //根据@Job注解的属性构造相应的Trigger\n    private Trigger getTrigger(Map<String,Object> paramKV,Method method, Job job, String triggerName){\n        TriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger().withIdentity(triggerName, LUCKY_JOB_GROUP);\n        String cron = job.cron();\n        String dyCron=job.dyCron();\n        if(!\"\".equals(dyCron)){\n            if(!paramKV.containsKey(dyCron))\n                throw new RuntimeException(\"定时任务 '\"+method+\" '缺少必要的dyCron参数：'(String)\"+dyCron+\"' \");\n            cron=(String)paramKV.get(dyCron);\n        }\n        //Cron表达式构建Trigger\n        if(!\"\".equals(cron)){\n            if(!CronExpression.isValidExpression(cron))\n                throw new CronExpressionException(method,cron);\n            Trigger trigger = triggerBuilder.startNow()\n                    .withSchedule(CronScheduleBuilder.cronSchedule(cron))\n                    .build();\n            return trigger;\n        }\n        long fixedDelay = job.fixedDelay();\n        String dyDelay=job.dyDelay();\n        if(!\"\".equals(dyDelay)){\n            if(!paramKV.containsKey(dyDelay))\n                throw new RuntimeException(\"定时任务 '\"+method+\" '缺少必要的参数：'(Long)\"+dyDelay+\"' \");\n            fixedDelay=(long)paramKV.get(dyDelay);\n        }\n\n        int count = job.count();\n        String dyCount=job.dyCount();\n        if(!\"\".equals(dyCount)){\n            if(!paramKV.containsKey(dyCount))\n                throw new RuntimeException(\"定时任务 '\"+method+\" '缺少必要的dyCount参数：'(Long)\"+dyCount+\"' \");\n            count=(int)paramKV.get(dyCount);\n        }\n\n        long interval = job.interval();\n        String dyInterval=job.dyInterval();\n        if(!\"\".equals(dyInterval)){\n            if(!paramKV.containsKey(dyInterval))\n                throw new RuntimeException(\"定时任务 '\"+method+\" '缺少必要的dyInterval参数：'(Long)\"+dyInterval+\"' \");\n            interval=(long)paramKV.get(dyInterval);\n        }\n\n\n\n        //构建一个固定延时且只会执行一次的Trigger\n        if(fixedDelay!=-1L){\n            Trigger trigger =triggerBuilder\n                    .startAt(futureDate((int) fixedDelay, DateBuilder.IntervalUnit.MILLISECOND))\n                    .build();\n            return trigger;\n        }\n\n        //构建一个相隔固定时间一次执行的Trigger(永不结束)\n        if(count<1){\n            Trigger trigger =triggerBuilder\n                    .withSchedule(simpleSchedule()\n                            .withIntervalInMilliseconds(interval)\n                            .repeatForever())\n                    .build();\n            return trigger;\n        }\n\n        //构建一个相隔固定时间一次执行,且执行count次后会结束的Trigger\n        Trigger trigger = triggerBuilder\n                .withSchedule(simpleSchedule().withIntervalInMilliseconds(interval).withRepeatCount((int)(count-1)))\n                .build();\n        return trigger;\n\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/com/lucky/jacklamb/quartz/proxy/QuartzMethodInterceptor.java	(revision b0db1e93fed51b608f5ad16c7410309a8bdac288)
+++ src/main/java/com/lucky/jacklamb/quartz/proxy/QuartzMethodInterceptor.java	(date 1595949020702)
@@ -52,7 +52,7 @@
             JobDetail jobDetail = JobBuilder.newJob(jobClass)
                     .withIdentity(jobName, LUCKY_JOB_GROUP)
                     .build();
-            //将任务逻辑的IocId put到上下文中
+            //将任务逻辑的IocId put到Job上下文中
             jobDetail.getJobDataMap().put(LUCKY_JOB,jobRunBeanId);
             Map<String, Object> paramKV = MethodUtils.getClassMethodParamsNV(method, params);
             Trigger trigger =getTrigger(paramKV,method,quartzJob,jobName);
